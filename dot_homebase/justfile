# justfile - Homebase user commands
#
# For living IN homebase (setup, updates, day-to-day use).
# Lives at ~/.homebase/justfile, shared across host and all containers via $HOME.
#
# Usage:
#   cd ~/.homebase && just setup         # full first-time setup (base)
#   cd ~/.homebase && just setup gamedev # base setup + gamedev extensions
#   cd ~/.homebase && just update        # update everything
#   homebase                             # shell alias for cd ~/.homebase && just

registry := "ghcr.io/farra"
image_name := "homebase"
runtime := `command -v podman 2>/dev/null || command -v docker 2>/dev/null || echo ""`

default:
    @just --list

# ── Authentication ───────────────────────────────────────────────────────

# [any] Sign in to 1Password (required for chezmoi secrets: SSH keys, GPG, authinfo)
auth:
    #!/usr/bin/env bash
    if op whoami &>/dev/null 2>&1; then
        echo "Already signed in to 1Password as: $(op whoami 2>/dev/null | head -1)"
    else
        echo "Signing in to 1Password..."
        eval "$(op signin)"
        echo "1Password session active."
    fi

# ── First-Time Setup ─────────────────────────────────────────────────────

# [any] Core setup shared by all profiles
setup-core: setup-workspace setup-flatpaks doom-install (agent "install")
    @echo ""
    @echo "Core setup complete!"
    @echo "  - Workspace directories created"
    @echo "  - Doom Emacs installed (run 'just doom-sync' after config changes)"
    @echo "  - AI agents installed (claude, claude-desktop, codex, gemini, acp)"

# Usage:
#   homebase setup            # base profile
#   homebase setup gamedev    # base + gamedev profile extensions
# [any] Full first-time setup (profile-aware)
setup profile="base": setup-core
    #!/usr/bin/env bash
    set -euo pipefail
    profile="{{profile}}"
    if [[ "$profile" != "base" ]]; then
        recipe="setup-profile-${profile}"
        if just --summary 2>/dev/null | tr ' ' '\n' | grep -qx "$recipe"; then
            just "$recipe"
        else
            echo "ERROR: No setup recipe '${recipe}' found for profile '${profile}'"
            echo "Add a '${recipe}' recipe to ~/.homebase/justfile to support this profile."
            exit 1
        fi
    fi
    echo ""
    echo "Setup complete for profile: $profile"

# [box] Profile-specific setup hook: gamedev (run inside gamedev distrobox)
setup-profile-gamedev: godot-export godot-templates
    @echo ""
    @echo "Gamedev profile setup complete."
    @echo "  - godot and godot-mono exported to host"
    @echo "  - Export templates linked"

# ── Workspace ────────────────────────────────────────────────────────────

# [any] Create workspace directory structure
setup-workspace:
    @echo "Creating workspace directories..."
    mkdir -p ~/dev/.worktrees ~/dev/me ~/dev/jmt ~/dev/ref
    @echo "  ~/dev/.worktrees/  — bare clones"
    @echo "  ~/dev/me/          — github.com/farra"
    @echo "  ~/dev/jmt/         — github.com/jamandtea"
    @echo "  ~/dev/ref/         — third-party / reference"

# ── Worktrees ────────────────────────────────────────────────────────────
# Bare clones in ~/dev/.worktrees/, worktrees in group dirs.
# Each worktree = one branch = one agent session.

# Usage: homebase clone farra/projectA
# [any] Bare-clone a repo into ~/dev/.worktrees/
clone repo:
    #!/usr/bin/env bash
    set -euo pipefail
    name="$(basename '{{repo}}')"
    dest="$HOME/dev/.worktrees/${name}.git"
    if [[ -d "$dest" ]]; then
        echo "Already cloned: $dest"
        exit 0
    fi
    git clone --bare "git@github.com:{{repo}}.git" "$dest"
    git -C "$dest" config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'
    git -C "$dest" fetch origin
    echo "Cloned: $dest"

# [any] List bare clones
clones:
    @ls -1 "$HOME/dev/.worktrees/" 2>/dev/null | sed 's/\.git$//' || echo "(none)"

# Usage: homebase wt projectA fix-auth [group]
# Branch slashes are flattened in directory name: local/build → project-local-build
# [any] Create a worktree from a bare clone
wt project branch group="me":
    #!/usr/bin/env bash
    set -euo pipefail
    bare="$HOME/dev/.worktrees/{{project}}.git"
    branch="{{branch}}"
    flat_branch="${branch//\//-}"
    dest="$HOME/dev/{{group}}/{{project}}-${flat_branch}"
    if [[ ! -d "$bare" ]]; then
        echo "No bare clone found: $bare"
        echo "Run: homebase clone <org>/{{project}}"
        exit 1
    fi
    if [[ -d "$dest" ]]; then
        echo "Worktree already exists: $dest"
        exit 0
    fi
    git -C "$bare" worktree add "$dest" -b "$branch"
    echo "Created: $dest (branch: $branch)"

# Branch slashes are flattened in directory name: feature/foo → project-feature-foo
# [any] Create a worktree from an existing remote branch
wt-checkout project branch group="me":
    #!/usr/bin/env bash
    set -euo pipefail
    bare="$HOME/dev/.worktrees/{{project}}.git"
    branch="{{branch}}"
    flat_branch="${branch//\//-}"
    dest="$HOME/dev/{{group}}/{{project}}-${flat_branch}"
    if [[ ! -d "$bare" ]]; then
        echo "No bare clone found: $bare"
        exit 1
    fi
    git -C "$bare" fetch origin
    git -C "$bare" worktree add "$dest" "$branch"
    echo "Checked out: $dest (branch: $branch)"

# Accepts absolute path, relative path from ~/dev/, or no args for interactive selection.
# Usage: homebase wt-rm jmt/gongfu-local-build
#        homebase wt-rm ~/dev/jmt/gongfu-local-build
#        homebase wt-rm                              (interactive picker)
# [any] Remove a worktree (keeps the branch)
wt-rm path="":
    #!/usr/bin/env bash
    set -euo pipefail
    HAS_GUM=false; command -v gum &>/dev/null && HAS_GUM=true
    _confirm() { if $HAS_GUM; then gum confirm "$1"; else read -rp "$1 [y/N] " a && [[ "$a" =~ ^[Yy]$ ]]; fi; }
    _choose() {
        local hdr="$1"; shift
        if $HAS_GUM; then printf '%s\n' "$@" | gum choose --header "$hdr"; return; fi
        echo "$hdr" >&2; local i=1; for o in "$@"; do echo "  $i) $o" >&2; ((i++)); done
        read -rp "Enter number: " c; [[ "$c" =~ ^[0-9]+$ ]] && (( c>=1 && c<=$# )) && echo "${!c}" || return 1
    }
    input="{{path}}"
    if [[ -z "$input" ]]; then
        # Collect all active worktrees
        declare -a wt_list=()
        for bare in "$HOME/dev/.worktrees/"*.git; do
            [[ -d "$bare" ]] || continue
            while IFS= read -r line; do
                wt_path="$(echo "$line" | awk '{print $1}')"
                [[ "$wt_path" == "$bare" ]] && continue
                wt_list+=("$wt_path")
            done < <(git -C "$bare" worktree list)
        done
        if [[ ${#wt_list[@]} -eq 0 ]]; then
            echo "No active worktrees found."
            exit 0
        fi
        target=$(_choose "Select worktree to remove:" "${wt_list[@]}") || exit 0
    elif [[ "$input" = /* ]]; then
        target="$input"
    else
        target="$HOME/dev/$input"
    fi
    if [[ ! -d "$target" ]]; then
        echo "Not found: $target"
        exit 1
    fi
    _confirm "Remove worktree: $target?" || exit 0
    bare="$(git -C "$target" rev-parse --git-common-dir 2>/dev/null)" || true
    if [[ -n "$bare" && -d "$bare" ]]; then
        git -C "$bare" worktree remove "$target"
        echo "Removed worktree: $target"
    else
        echo "Not a git worktree: $target"
        exit 1
    fi

# [any] List all active worktrees across all bare clones
wts:
    #!/usr/bin/env bash
    for bare in "$HOME/dev/.worktrees/"*.git; do
        [[ -d "$bare" ]] || continue
        name="$(basename "$bare" .git)"
        trees="$(git -C "$bare" worktree list | tail -n +2)"
        if [[ -n "$trees" ]]; then
            echo "── $name ──"
            echo "$trees"
            echo ""
        fi
    done

# ── Updates ──────────────────────────────────────────────────────────────

# [any] Update everything (dotfiles + host tools + flatpaks + agents)
update: update-dotfiles update-host update-flatpaks (agent "update")
    @echo ""
    @echo "All updates complete."

# [any] Pull and apply latest dotfiles
update-dotfiles:
    #!/usr/bin/env bash
    set -euo pipefail
    HAS_GUM=false; command -v gum &>/dev/null && HAS_GUM=true
    _spin() { if $HAS_GUM; then gum spin --spinner dot --title "$1" -- "${@:2}"; else echo "$1"; "${@:2}"; fi; }
    _spin "Updating dotfiles..." chezmoi update --force

# [host] Update host tools (Homebrew) — skipped inside distrobox
update-host:
    #!/usr/bin/env bash
    set -euo pipefail
    HAS_GUM=false; command -v gum &>/dev/null && HAS_GUM=true
    _spin() { if $HAS_GUM; then gum spin --spinner dot --title "$1" -- "${@:2}"; else echo "$1"; "${@:2}"; fi; }
    if [[ -f /run/.containerenv ]]; then
        echo "Inside a container — skipping host tool update."
        echo "Run this on the host to update Homebrew."
        exit 0
    fi
    CHEZMOI_SOURCE="$(chezmoi source-path 2>/dev/null || echo "$HOME/.local/share/chezmoi")"
    RENDERER="${CHEZMOI_SOURCE}/scripts/render-brewfile.sh"
    TOML="${CHEZMOI_SOURCE}/homebase.toml"
    if [[ ! -x "$RENDERER" ]]; then
        echo "ERROR: Brewfile renderer not found: $RENDERER"
        exit 1
    fi
    tmp_brewfile="$(mktemp)"
    trap 'rm -f "$tmp_brewfile"' EXIT
    "$RENDERER" "$TOML" > "$tmp_brewfile"
    _spin "Updating host tools (Homebrew)..." brew bundle --file="$tmp_brewfile" --upgrade

# ── Flatpak Apps ─────────────────────────────────────────────────────────

# [host] Install Flatpak apps declared in homebase.toml — skipped inside distrobox
setup-flatpaks:
    #!/usr/bin/env bash
    set -euo pipefail
    HAS_GUM=false; command -v gum &>/dev/null && HAS_GUM=true
    _spin() { if $HAS_GUM; then gum spin --spinner dot --title "$1" -- "${@:2}"; else echo "$1"; "${@:2}"; fi; }
    if [[ -f /run/.containerenv ]]; then
        echo "Inside a container — skipping Flatpak setup."
        exit 0
    fi
    if ! command -v flatpak &>/dev/null; then
        echo "flatpak not found — skipping (not applicable on this platform)."
        exit 0
    fi
    CHEZMOI_SOURCE="$(chezmoi source-path 2>/dev/null || echo "$HOME/.local/share/chezmoi")"
    PARSER="${CHEZMOI_SOURCE}/scripts/parse-toml-array.sh"
    TOML="${CHEZMOI_SOURCE}/homebase.toml"
    if [[ ! -x "$PARSER" ]]; then
        echo "ERROR: TOML parser not found: $PARSER"
        exit 1
    fi
    echo "Installing Flatpak apps from homebase.toml..."
    while IFS= read -r app_id; do
        if flatpak info "$app_id" &>/dev/null; then
            echo "  Already installed: $app_id"
        else
            _spin "  Installing $app_id..." flatpak install --noninteractive flathub "$app_id"
        fi
    done < <("$PARSER" flatpaks apps "$TOML")
    echo "Flatpak setup complete."

# [host] Update all installed Flatpak apps — skipped inside distrobox
update-flatpaks:
    #!/usr/bin/env bash
    set -euo pipefail
    HAS_GUM=false; command -v gum &>/dev/null && HAS_GUM=true
    _spin() { if $HAS_GUM; then gum spin --spinner dot --title "$1" -- "${@:2}"; else echo "$1"; "${@:2}"; fi; }
    if [[ -f /run/.containerenv ]]; then
        echo "Inside a container — skipping Flatpak update."
        exit 0
    fi
    if ! command -v flatpak &>/dev/null; then
        echo "flatpak not found — skipping (not applicable on this platform)."
        exit 0
    fi
    _spin "Updating Flatpak apps..." flatpak update --noninteractive
    echo "Flatpak update complete."

# [host] Remove a single Flatpak app (remember to also remove it from homebase.toml)
remove-flatpak app_id:
    #!/usr/bin/env bash
    set -euo pipefail
    HAS_GUM=false; command -v gum &>/dev/null && HAS_GUM=true
    _confirm() { if $HAS_GUM; then gum confirm "$1"; else read -rp "$1 [y/N] " a && [[ "$a" =~ ^[Yy]$ ]]; fi; }
    if ! command -v flatpak &>/dev/null; then
        echo "flatpak not found."
        exit 1
    fi
    _confirm "Remove Flatpak app '{{app_id}}'?" || exit 0
    flatpak uninstall --noninteractive "{{app_id}}"
    echo "Removed: {{app_id}}"
    echo "Remember to also remove it from homebase.toml [flatpaks] apps."

# ── Box Lifecycle ────────────────────────────────────────────────────────
#
# Canonical interface:
#   homebase box create            # base profile -> box name "home"
#   homebase box enter             # enter "home"
#   homebase box create gamedev    # gamedev profile -> box name "gamedev"
#   homebase box enter gamedev
#   homebase box rm gamedev
#   homebase box rebuild gamedev
#
# Syntax:
#   homebase box <action> [profile] [name]
# Actions: create | enter | rm | rebuild
# [host] Manage distrobox containers (create, enter, rm, rebuild)
box action profile="base" name="":
    #!/usr/bin/env bash
    set -euo pipefail
    HAS_GUM=false; command -v gum &>/dev/null && HAS_GUM=true
    _confirm() { if $HAS_GUM; then gum confirm "$1"; else read -rp "$1 [y/N] " a && [[ "$a" =~ ^[Yy]$ ]]; fi; }
    _spin() { if $HAS_GUM; then gum spin --spinner dot --title "$1" -- "${@:2}"; else echo "$1"; "${@:2}"; fi; }
    _choose() {
        local hdr="$1"; shift
        if $HAS_GUM; then printf '%s\n' "$@" | gum choose --header "$hdr"; return; fi
        echo "$hdr" >&2; local i=1; for o in "$@"; do echo "  $i) $o" >&2; ((i++)); done
        read -rp "Enter number: " c; [[ "$c" =~ ^[0-9]+$ ]] && (( c>=1 && c<=$# )) && echo "${!c}" || return 1
    }

    if [[ -z "{{runtime}}" ]]; then
        echo "ERROR: Neither podman nor docker found. Install one first."
        exit 1
    fi

    _box_create() {
        local image_ref="$1" box_name="$2"
        local extra_flags=""
        if [[ -d "/home/linuxbrew" ]]; then
            extra_flags+=" --volume /home/linuxbrew:/home/linuxbrew"
        fi
        # Bind-mount NVIDIA drivers into container if present on host
        if [[ -e /dev/nvidia0 ]]; then
            extra_flags+=" --nvidia"
        fi
        distrobox create --image "$image_ref" --name "$box_name" \
            --init-hooks 'usermod -s /usr/bin/zsh "$(whoami)"' \
            $extra_flags
        # Run init to completion before first enter (works around distrobox
        # log-tailing race where enter hangs or the container exits with code 1)
        echo "Initializing container '$box_name'..."
        {{runtime}} start "$box_name" >/dev/null 2>&1 || true
        # Wait for distrobox-init to finish (creates /.containersetupdone)
        local tries=0
        while ! {{runtime}} exec "$box_name" test -f /.containersetupdone 2>/dev/null; do
            sleep 2
            tries=$((tries + 1))
            if [[ $tries -ge 60 ]]; then
                echo "WARNING: Container init timed out after 120s"
                break
            fi
        done
        echo "Container '$box_name' ready."
    }

    action="{{action}}"
    profile="{{profile}}"
    box_name="{{name}}"

    if [[ "$profile" == "base" ]]; then
        image_ref="{{registry}}/{{image_name}}:latest"
        default_box_name="home"
    else
        image_ref="{{registry}}/{{image_name}}:${profile}-latest"
        default_box_name="$profile"
    fi

    if [[ -z "$box_name" ]]; then
        box_name="$default_box_name"
    fi

    case "$action" in
        create)
            _spin "Pulling $image_ref..." {{runtime}} pull "$image_ref"
            _box_create "$image_ref" "$box_name"
            ;;
        enter)
            if ! {{runtime}} container exists "$box_name" 2>/dev/null; then
                mapfile -t boxes < <(distrobox list --no-color 2>/dev/null | tail -n +2 | awk -F'|' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); print $2}')
                if [[ ${#boxes[@]} -eq 0 ]]; then
                    echo "No distrobox containers found. Run: homebase box create"
                    exit 1
                fi
                box_name=$(_choose "Container '$box_name' not found. Pick one:" "${boxes[@]}") || exit 1
            fi
            distrobox enter "$box_name"
            ;;
        rm)
            _confirm "Remove container '$box_name'? This is destructive." || exit 0
            distrobox rm "$box_name" --force
            ;;
        rebuild)
            _confirm "Rebuild container '$box_name'? This will destroy and recreate it." || exit 0
            distrobox rm "$box_name" --force 2>/dev/null || true
            _spin "Pulling $image_ref..." {{runtime}} pull "$image_ref"
            _box_create "$image_ref" "$box_name"
            ;;
        *)
            echo "ERROR: Unknown box action '$action'"
            echo "Usage: homebase box <create|enter|rm|rebuild> [profile] [name]"
            exit 1
            ;;
    esac

# ── Doom Emacs ───────────────────────────────────────────────────────────

# [box] Install Doom Emacs (clone + install)
doom-install:
    #!/usr/bin/env bash
    set -euo pipefail
    if [[ -d "$HOME/.emacs.d/bin" ]]; then
        echo "Doom Emacs already installed at ~/.emacs.d"
        echo "Run 'just doom-reinstall' to force reinstall"
        exit 0
    fi
    # Back up any existing .emacs.d
    if [[ -d "$HOME/.emacs.d" ]]; then
        echo "Backing up existing ~/.emacs.d to ~/.emacs.d.bak"
        mv "$HOME/.emacs.d" "$HOME/.emacs.d.bak"
    fi
    echo "Cloning Doom Emacs..."
    git clone --depth 1 https://github.com/doomemacs/doomemacs "$HOME/.emacs.d"
    echo "Running doom install..."
    "$HOME/.emacs.d/bin/doom" install
    echo "Doom Emacs installed. Config at ~/.config/doom/ (managed by chezmoi)"

# [box] Reinstall Doom Emacs from scratch
doom-reinstall:
    #!/usr/bin/env bash
    set -euo pipefail
    HAS_GUM=false; command -v gum &>/dev/null && HAS_GUM=true
    _confirm() { if $HAS_GUM; then gum confirm "$1"; else read -rp "$1 [y/N] " a && [[ "$a" =~ ^[Yy]$ ]]; fi; }
    _confirm "Reinstall Doom Emacs? This will delete ~/.emacs.d entirely." || exit 0
    rm -rf "$HOME/.emacs.d"
    just doom-install

# [box] Sync Doom Emacs (after config changes)
doom-sync:
    ~/.emacs.d/bin/doom sync

# [box] Run Doom doctor
doom-doctor:
    ~/.emacs.d/bin/doom doctor

# [box] Export Emacs to host desktop (distrobox only)
doom-export:
    distrobox-export --app emacs 2>/dev/null || echo "Not in a distrobox?"

# ── Godot (gamedev profile) ──────────────────────────────────────────────

# [box] Export Godot editors to host desktop (run inside gamedev distrobox)
godot-export:
    #!/usr/bin/env bash
    set -euo pipefail
    if [[ ! -f /run/.containerenv ]]; then
        echo "Not in a distrobox. Run this inside the gamedev container."
        exit 1
    fi
    if command -v godot &>/dev/null; then
        distrobox-export --bin /usr/local/bin/godot --export-path ~/.local/bin/
    else
        echo "godot not found — is this the gamedev container?"
    fi
    if command -v godot-mono &>/dev/null; then
        distrobox-export --bin /usr/local/bin/godot-mono --export-path ~/.local/bin/
    fi

# [box] Symlink baked export templates to Godot's expected location
godot-templates:
    #!/usr/bin/env bash
    set -euo pipefail
    if [[ ! -d /opt/godot/export_templates ]]; then
        echo "No export templates found in /opt/godot/ — is this the gamedev container?"
        exit 1
    fi
    mkdir -p ~/.local/share/godot/export_templates
    for tpl_dir in /opt/godot/export_templates/*/; do
        version="$(basename "$tpl_dir")"
        target="$HOME/.local/share/godot/export_templates/$version"
        if [[ -L "$target" || -d "$target" ]]; then
            echo "  Already linked: $version"
        else
            ln -sf "$tpl_dir" "$target"
            echo "  Linked: $version"
        fi
    done
    echo "Export templates available in Godot editor."

# ── AI Agents ────────────────────────────────────────────────────────────
#
# Canonical interface:
#   homebase agent install           # install all agents
#   homebase agent update            # update all agents
#   homebase agent install claude    # install only claude
#   homebase agent update codex     # update only codex
#
# Agents: claude | claude-desktop | codex | gemini | acp

# [any] Install or update AI agent CLIs, desktop app, and ACP adapters
agent action name="all":
    #!/usr/bin/env bash
    set -euo pipefail

    _install_claude() {
        if command -v claude &>/dev/null; then
            echo "Claude Code already installed: $(claude --version 2>/dev/null || echo 'unknown version')"
            echo "Run 'homebase agent update claude' to update"
            return 0
        fi
        echo "Installing Claude Code..."
        curl -fsSL https://claude.ai/install.sh | bash
        echo "Claude Code installed"
    }

    _update_claude() {
        curl -fsSL https://claude.ai/install.sh | bash
    }

    _install_claude_desktop() {
        if [[ ! -f /run/.containerenv ]]; then
            echo "Not in a distrobox — skipping Claude Desktop install."
            return 0
        fi
        if command -v claude-desktop &>/dev/null; then
            echo "Claude Desktop already installed: $(claude-desktop --version 2>/dev/null || echo 'unknown version')"
            echo "Run 'homebase agent update claude-desktop' to update"
            return 0
        fi
        # Add DNF repo if not present
        if [[ ! -f /etc/yum.repos.d/claude-desktop.repo ]]; then
            echo "Adding Claude Desktop DNF repository..."
            sudo curl -fsSL https://aaddrick.github.io/claude-desktop-debian/rpm/claude-desktop.repo \
                -o /etc/yum.repos.d/claude-desktop.repo
        fi
        echo "Installing Claude Desktop..."
        sudo dnf install -y claude-desktop
        echo "Exporting Claude Desktop to host..."
        distrobox-export --app claude-desktop 2>/dev/null || echo "Export failed — you may need to export manually."
        echo "Claude Desktop installed and exported to host desktop."
    }

    _update_claude_desktop() {
        if [[ ! -f /run/.containerenv ]]; then
            echo "Not in a distrobox. Run this inside the home container."
            return 0
        fi
        sudo dnf upgrade -y claude-desktop
    }

    _install_codex() {
        if command -v codex &>/dev/null; then
            echo "Codex already installed: $(codex --version 2>/dev/null || echo 'unknown version')"
            echo "Run 'homebase agent update codex' to update"
            return 0
        fi
        echo "Installing Codex CLI..."
        brew install codex
        echo "Codex CLI installed"
    }

    _update_codex() {
        brew upgrade codex || brew install codex
    }

    _install_gemini() {
        if command -v gemini &>/dev/null; then
            echo "Gemini CLI already installed: $(gemini --version 2>/dev/null || echo 'unknown version')"
            echo "Run 'homebase agent update gemini' to update"
            return 0
        fi
        echo "Installing Gemini CLI..."
        brew install gemini-cli
        echo "Gemini CLI installed"
    }

    _update_gemini() {
        brew upgrade gemini-cli || brew install gemini-cli
    }

    _install_acp() {
        echo "Installing ACP adapters for agent-shell..."
        npm install -g @zed-industries/claude-agent-acp
        npm install -g @zed-industries/codex-acp
        echo "ACP adapters installed (claude-agent-acp, codex-acp)"
        echo "Note: Gemini has native ACP support via --experimental-acp (no adapter needed)"
    }

    _update_acp() {
        npm install -g @zed-industries/claude-agent-acp
        npm install -g @zed-industries/codex-acp
    }

    all_agents=(claude claude-desktop codex gemini acp)

    _dispatch_one() {
        local act="$1" agent="$2"
        case "$agent" in
            claude)         "_${act}_claude" ;;
            claude-desktop) "_${act}_claude_desktop" ;;
            codex)          "_${act}_codex" ;;
            gemini)         "_${act}_gemini" ;;
            acp)            "_${act}_acp" ;;
            *)
                echo "ERROR: Unknown agent '$agent'"
                echo "Agents: ${all_agents[*]}"
                return 1
                ;;
        esac
    }

    action="{{action}}"
    name="{{name}}"

    case "$action" in
        install|update)
            if [[ "$name" == "all" ]]; then
                for a in "${all_agents[@]}"; do
                    echo "── $action $a ──"
                    _dispatch_one "$action" "$a"
                    echo ""
                done
            else
                _dispatch_one "$action" "$name"
            fi
            ;;
        *)
            echo "ERROR: Unknown action '$action'"
            echo "Usage: homebase agent <install|update> [agent-name|all]"
            echo "Agents: ${all_agents[*]}"
            exit 1
            ;;
    esac
